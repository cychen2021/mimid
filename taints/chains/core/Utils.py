# coding=utf-8
"""
Contains important values and function that are used as utilities.
"""
import string
from core.Heap import Heap

from typing import Dict, Set, Tuple

# a set of characters from which one could be randomly chosen if guessing is necessary
continuations = [i for i in string.printable]

# the heuristic value to start with
START_H_VALUE = 1000

# get the minimal index seen in comparisons, everything before is not relevant
min_index = 0

# get the index of the last comparison made except eof
last_comparison_index = 0

# get the maximal index seen in comparisons, this index is used to calculate the coverage heuristic
max_index_comparison = 0

# the prio queue
inputs = Heap()

# the already covered branches
covered_branches = set()

# map character to reducing or increasing stacksize
map_char_stack = dict()

# covered paths (used for calculating heuristic value)
covered_paths = dict()

# the flag that is used if the program needs a command line flag (e.g. <Program> -g_flag <input>)
g_flag = ""

# defines if the input is given as argument or via some other input channel
as_arg = False

# for each character the functions that were thrown off the stack after the char was successfully applied, i.e. a successful comparison was performed
char_fun_mapping: Dict[str, Set] = dict()

# branches covered by valid inputs, those should not be considered anymore when calculating heuristics
valid_covered: Dict[Tuple[int, int], int] = dict()

# the valid inputs that were found by now
valid_found = set()

# the inputs that will be provided to afl (invalid and hanging inputs will not be present in this set)
seed_for_afl = set()

# file for printing stats
stats_file = None

# counter for how many values were executed by now
all_exec = 1

# counter for how many inputs were generated since last found
current_iteration = 0

# the subject that is currently fuzzed
subject = ""

# the current working directory
cwd = ""

# the time the fuzzer was started
starttime = 0

# defines the socket port over which is fuzzed (-1 if fuzzing is not done over a socket)
socketport = -1

# defines if all found valid inputs should be printed
printall = False

# defines the function at which to stop exploration
stop_function = ""


def is_real_input_comparison(obj, max_idx):
    """
    Some comparisons are no real input comparisons as they are artificially generated by the tainting framework.
    Returns true if the comparison is a real comparison (e.g. no strlen comparison)
    :param obj:
    :param max_idx: The maximum index to which the comparison should be counted as real. All indeces > max_index are not counted as real.
    :return:
    """
    return obj["type"] == "INPUT_COMPARISON" and obj["operator"] not in {"strlen", "eof", "tokenstore", "strconstcmp", "assert"} and obj["index"][-1] <= max_idx
